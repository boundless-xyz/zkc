#!/bin/bash
set -euo pipefail

# Load environment configuration from TOML files
load_env_var() {
    local key="$1"
    local var_name="$2"
    local file="${3:-deployment.toml}"
    
    # Try secrets file first if it exists
    if [[ -f "deployment_secrets.toml" ]] && [[ "$file" == "deployment_secrets.toml" ]]; then
        value=$(python3 -c "
import tomlkit
try:
    doc = tomlkit.load(open('deployment_secrets.toml'))
    print(doc['deployment']['$CHAIN_KEY'].get('$key', ''))
except:
    print('')
" 2>/dev/null || echo "")
        if [[ -n "$value" ]]; then
            export "$var_name"="$value"
            return
        fi
    fi
    
    # Fallback to main deployment.toml
    value=$(python3 -c "
import tomlkit
try:
    doc = tomlkit.load(open('deployment.toml'))
    print(doc['deployment']['$CHAIN_KEY'].get('$key', ''))
except:
    print('')
" 2>/dev/null || echo "")
    if [[ -n "$value" ]]; then
        export "$var_name"="$value"
    fi
}

# Check prerequisites
check_prerequisites() {
    echo "Checking prerequisites..."
    
    command -v python3 >/dev/null 2>&1 || { 
        echo "‚ùå python3 is required but not installed"
        exit 1
    }
    
    python3 -c "import tomlkit" 2>/dev/null || { 
        echo "‚ùå tomlkit is required: pip install tomlkit"
        exit 1
    }
    
    command -v yq >/dev/null 2>&1 || { 
        echo "‚ùå yq is required: brew install yq"
        exit 1
    }
    
    command -v cast >/dev/null 2>&1 || { 
        echo "‚ùå cast is required: install Foundry"
        exit 1
    }
    
    echo "‚úÖ All prerequisites satisfied"
}

# Create reference build for upgrades
create_reference_build() {
    local deployed_commit
    
    echo "Creating reference build for upgrade safety checks..."
    
    # Get deployed commit from deployment.toml
    deployed_commit=$(python3 -c "
import tomlkit
doc = tomlkit.load(open('deployment.toml'))
commit = doc['deployment']['$CHAIN_KEY'].get('deployment-commit', '')
if not commit:
    raise Exception('No deployment commit found for $CHAIN_KEY')
print(commit.strip())
")
    
    if [[ -z "$deployed_commit" ]]; then
        echo "‚ùå No deployment commit found for $CHAIN_KEY"
        echo "Cannot create reference build for upgrade"
        exit 1
    fi
    
    echo "üì¶ Creating reference build from commit: $deployed_commit"
    
    # Create worktree for reference build
    local worktree_path="../zkc-reference-${deployed_commit}"
    
    # Clean up existing worktree if it exists
    if [[ -d "$worktree_path" ]]; then
        echo "üßπ Cleaning up existing reference worktree..."
        git worktree remove "$worktree_path" --force 2>/dev/null || true
    fi
    
    # Clean up existing reference build info
    if [[ -d "build-info-reference" ]]; then
        echo "üßπ Cleaning up existing reference build info..."
        rm -rf "build-info-reference"
    fi
    
    # Create new worktree
    git worktree add "$worktree_path" "$deployed_commit"
    
    # Build reference and copy build info
    echo "üî® Building reference contracts..."
    (
        cd "$worktree_path"
        # Clean and do a full build to ensure complete build info
        forge clean
        FOUNDRY_PROFILE=reference forge build
        
        # Check if build info was created
        if [[ ! -d "out-reference/build-info" ]] || [[ -z "$(ls -A out-reference/build-info 2>/dev/null)" ]]; then
            echo "‚ùå No build info created in reference build"
            echo "Trying default build..."
            forge clean
            forge build
            if [[ -d "out/build-info" ]]; then
                mkdir -p "$OLDPWD/build-info-reference"
                cp -R out/build-info/* "$OLDPWD/build-info-reference/"
            fi
        else
            mkdir -p "$OLDPWD/build-info-reference"
            cp -R out-reference/build-info/* "$OLDPWD/build-info-reference/"
        fi
    )
    
    # Clean up worktree
    git worktree remove "$worktree_path" --force
    
    # Verify build info was copied
    if [[ -d "build-info-reference" ]] && [[ -n "$(ls -A build-info-reference 2>/dev/null)" ]]; then
        echo "‚úÖ Reference build created in build-info-reference/"
        echo "üìÅ Build info files: $(ls -1 build-info-reference | wc -l) files"
    else
        echo "‚ùå Failed to create reference build info"
        echo "This may cause upgrade validation to fail"
    fi
}

# Execute forge script with proper configuration
forge_script() {
    local script_name="$1"
    shift
    
    echo "üöÄ Executing $script_name..."
    
    # Determine the correct script file
    local script_file
    if [[ "$script_name" == Deploy* ]]; then
        script_file="Deploy.s.sol"
    elif [[ "$script_name" == Upgrade* ]]; then
        script_file="Upgrade.s.sol"
    elif [[ "$script_name" == Rollback* ]]; then
        script_file="Rollback.s.sol"
    elif [[ "$script_name" == Update* ]]; then
        script_file="Update.s.sol"
    elif [[ "$script_name" == Dev_* ]]; then
        script_file="Ops.s.sol"
    else
        echo "‚ùå Unknown script type: $script_name"
        exit 1
    fi
    
    local cmd="forge script script/$script_file:$script_name"
    cmd="$cmd --rpc-url $RPC_URL"
    
    # Add etherscan verification if available
    if [[ -n "${ETHERSCAN_API_KEY:-}" ]]; then
        cmd="$cmd --etherscan-api-key $ETHERSCAN_API_KEY"
    fi
    
    # Configure signing method
    if [[ "$USE_FIREBLOCKS" == "true" ]]; then
        if ! command -v fireblocks-json-rpc >/dev/null 2>&1; then
            echo "‚ùå fireblocks-json-rpc not found in PATH"
            echo "Install from: https://github.com/fireblocks/fireblocks-json-rpc"
            exit 1
        fi
        
        if [[ -z "${FIREBLOCKS_API_KEY:-}" ]]; then
            echo "‚ùå FIREBLOCKS_API_KEY not set"
            exit 1
        fi
        
        cmd="fireblocks-json-rpc --http -- $cmd"
    else
        cmd="$cmd --private-key $PRIVATE_KEY"
    fi
    
    # Add optional flags
    for arg in "$@"; do
        cmd="$cmd $arg"
    done
    
    echo "üìù Running: $cmd"
    eval "$cmd"
    
    # deployment.toml is now updated automatically via FFI calls in the Solidity scripts
    if [[ "$script_name" == "Deploy"* ]] && [[ " $@ " == *" --broadcast "* ]]; then
        echo "‚úÖ Deployment completed - deployment.toml updated automatically"
    elif [[ "$script_name" == "Upgrade"* ]] && [[ " $@ " == *" --broadcast "* ]]; then
        echo "‚úÖ Upgrade completed - deployment.toml updated automatically"
    fi
}

# Deployment.toml is now updated automatically via FFI calls in Solidity scripts

# Print usage information
usage() {
    cat << EOF
Usage: $0 <command> [options]

Commands:
  deploy-zkc             Deploy ZKC token contract
  deploy-vezkc           Deploy veZKC staking contract
  deploy-staking         Deploy StakingRewards contract
  upgrade-zkc            Upgrade ZKC implementation
  upgrade-vezkc          Upgrade veZKC implementation  
  upgrade-staking        Upgrade StakingRewards implementation
  rollback-zkc           Rollback ZKC to previous implementation
  rollback-vezkc         Rollback veZKC to previous implementation
  rollback-staking       Rollback StakingRewards to previous implementation
  update-povw-minter     Set POVW_MINTER_ROLE in ZKC contract
  update-staking-minter  Set STAKING_MINTER_ROLE in ZKC contract
  dev-mint-to-self       Development: mint initial tokens to caller

Options:
  -f, --fireblocks       Use Fireblocks for transaction signing
  --broadcast            Broadcast transactions to network
  --verify               Verify contracts on Etherscan
  -h, --help             Show this help message

Environment Variables:
  CHAIN_KEY              Required. Deployment environment key (anvil, ethereum-mainnet, ethereum-sepolia, ethereum-sepolia-staging)
  PRIVATE_KEY            Required. Private key for transaction signing (0x...)
  
Examples:
  # Deploy ZKC to anvil
  CHAIN_KEY=anvil \
  PRIVATE_KEY=0x... \
  INITIAL_MINTER_1="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266" \
  INITIAL_MINTER_2="0x0000000000000000000000000000000000000000" \
  TOTAL_INITIAL_SUPPLY="1000000000000000000000000000" \
  INITIAL_MINTER_1_AMOUNT="1000000000000000000000000000" \
  INITIAL_MINTER_2_AMOUNT="0" \
  SALT="0x0000000000000000000000000000000000000000000000000000000000000001" \
  ADMIN="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266" \
  script/manage deploy-zkc --broadcast
  
  # Deploy veZKC to sepolia with Fireblocks (requires ZKC already deployed)
  PRIVATE_KEY=0x... CHAIN_KEY=ethereum-sepolia ./script/manage deploy-vezkc --fireblocks --broadcast --verify
  
  # Deploy to staging environment
  PRIVATE_KEY=0x... CHAIN_KEY=ethereum-sepolia-staging ./script/manage deploy-zkc --broadcast
  
  # Deploy StakingRewards to anvil (requires ZKC and veZKC already deployed)
  PRIVATE_KEY=0x... CHAIN_KEY=anvil ./script/manage deploy-staking --broadcast
  
  # Upgrade ZKC on mainnet with verification
  PRIVATE_KEY=0x... CHAIN_KEY=ethereum-mainnet ./script/manage upgrade-zkc --broadcast --verify
  
  # Rollback ZKC to previous implementation
  PRIVATE_KEY=0x... CHAIN_KEY=anvil ./script/manage rollback-zkc --broadcast
  
  # Set POVW minter role (requires POVW_MINTER env var)
  PRIVATE_KEY=0x... POVW_MINTER=0x123... CHAIN_KEY=anvil ./script/manage update-povw-minter --broadcast
  
  # Development: mint initial tokens to self (requires MINT_AMOUNT env var)
  PRIVATE_KEY=0x... MINT_AMOUNT=1000000000000000000000000 CHAIN_KEY=anvil ./script/manage dev-mint-to-self --broadcast

Notes:
  - Network configuration is loaded from deployment.toml and deployment_secrets.toml
  - Private keys must be provided via PRIVATE_KEY environment variable
  - Upgrades require reference builds for safety checks
  - Fireblocks requires fireblocks-json-rpc to be installed
  - All deployments automatically update deployment.toml
EOF
}

# Main execution logic
main() {
    echo "üîß ZKC Deployment Manager"
    echo "=========================="
    
    # Parse flags first
    USE_FIREBLOCKS=false
    SCRIPT_ARGS=()
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--fireblocks)
                USE_FIREBLOCKS=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            deploy-*|upgrade-*|rollback-*|update-*|dev-*)
                COMMAND="$1"
                shift
                ;;
            *)
                SCRIPT_ARGS+=("$1")
                shift
                ;;
        esac
    done
    
    # Check for required command
    if [[ -z "${COMMAND:-}" ]]; then
        echo "‚ùå No command specified"
        usage
        exit 1
    fi
    
    # Check prerequisites
    check_prerequisites
    
    # Required environment variable
    if [[ -z "${CHAIN_KEY:-}" ]]; then
        echo "‚ùå CHAIN_KEY environment variable is required"
        echo "Example: CHAIN_KEY=anvil ./script/manage deploy-all --broadcast"
        exit 1
    fi
    
    echo "üåê Chain: $CHAIN_KEY"
    
    # Load configuration from TOML files
    echo "üìã Loading configuration..."
    load_env_var "rpc-url" "RPC_URL" "deployment_secrets.toml"
    load_env_var "etherscan-api-key" "ETHERSCAN_API_KEY" "deployment_secrets.toml"
    load_env_var "id" "CHAIN_ID"
    
    # PRIVATE_KEY must be set as environment variable
    if [[ -z "${PRIVATE_KEY:-}" ]]; then
        echo "‚ùå PRIVATE_KEY environment variable is required"
        echo "Set it with: export PRIVATE_KEY=0x..."
        exit 1
    fi
    
    if [[ "$USE_FIREBLOCKS" == "true" ]]; then
        load_env_var "fireblocks-api-key" "FIREBLOCKS_API_KEY" "deployment_secrets.toml"
        echo "üîê Using Fireblocks for signing"
    fi
    
    # Verify required configuration
    if [[ -z "${RPC_URL:-}" ]]; then
        echo "‚ùå RPC URL not configured for $CHAIN_KEY"
        exit 1
    fi
    
    if [[ -z "${CHAIN_ID:-}" ]]; then
        echo "‚ùå Chain ID not configured for $CHAIN_KEY"
        exit 1
    fi
    
    # Verify chain ID matches RPC
    echo "üîç Verifying chain configuration..."
    actual_chain_id=$(cast chain-id --rpc-url "$RPC_URL" 2>/dev/null || echo "")
    if [[ "$actual_chain_id" != "$CHAIN_ID" ]]; then
        echo "‚ùå Chain ID mismatch:"
        echo "   Expected: $CHAIN_ID (from deployment.toml)"
        echo "   Actual:   $actual_chain_id (from RPC)"
        exit 1
    fi
    echo "‚úÖ Chain ID verified: $CHAIN_ID"
    
    # Create reference build for upgrade commands
    if [[ "$COMMAND" == upgrade-* ]]; then
        create_reference_build
        
        # Also ensure current build is clean and complete
        echo "üî® Ensuring current build is complete..."
        forge clean
        forge build
        echo "‚úÖ Current build completed"
    fi
    
    # Execute the requested command
    case "$COMMAND" in
        deploy-zkc)
            forge_script "DeployZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        deploy-vezkc)
            forge_script "DeployVeZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        deploy-staking)
            forge_script "DeployStakingRewards" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        upgrade-zkc)
            forge_script "UpgradeZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        upgrade-vezkc)
            forge_script "UpgradeVeZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        upgrade-staking)
            forge_script "UpgradeStakingRewards" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        rollback-zkc)
            forge_script "RollbackZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        rollback-vezkc)
            forge_script "RollbackVeZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        rollback-staking)
            forge_script "RollbackStakingRewards" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        update-povw-minter)
            forge_script "UpdatePOVWMinter" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        update-staking-minter)
            forge_script "UpdateStakingMinter" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        dev-mint-to-self)
            forge_script "Dev_InitialMintToSelf" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        *)
            echo "‚ùå Unknown command: $COMMAND"
            usage
            exit 1
            ;;
    esac
    
    echo ""
    echo "‚úÖ Command completed successfully: $COMMAND"
    echo "=========================="
}

# Run main function with all arguments
main "$@"