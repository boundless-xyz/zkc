#!/bin/bash
set -euo pipefail

# Load environment configuration from TOML files
load_env_var() {
    local key="$1"
    local var_name="$2"
    local file="${3:-deployment.toml}"
    
    # Try secrets file first if it exists
    if [[ -f "deployment_secrets.toml" ]] && [[ "$file" == "deployment_secrets.toml" ]]; then
        value=$(python3 -c "
import tomlkit
try:
    doc = tomlkit.load(open('deployment_secrets.toml'))
    print(doc['deployment']['$CHAIN_KEY'].get('$key', ''))
except:
    print('')
" 2>/dev/null || echo "")
        if [[ -n "$value" ]]; then
            export "$var_name"="$value"
            return
        fi
    fi
    
    # Fallback to main deployment.toml
    value=$(python3 -c "
import tomlkit
try:
    doc = tomlkit.load(open('deployment.toml'))
    print(doc['deployment']['$CHAIN_KEY'].get('$key', ''))
except:
    print('')
" 2>/dev/null || echo "")
    if [[ -n "$value" ]]; then
        export "$var_name"="$value"
    fi
}

# Check prerequisites
check_prerequisites() {
    echo "Checking prerequisites..."
    
    command -v python3 >/dev/null 2>&1 || { 
        echo "‚ùå python3 is required but not installed"
        exit 1
    }
    
    python3 -c "import tomlkit" 2>/dev/null || { 
        echo "‚ùå tomlkit is required: pip install tomlkit"
        exit 1
    }
    
    command -v yq >/dev/null 2>&1 || { 
        echo "‚ùå yq is required: brew install yq"
        exit 1
    }
    
    command -v cast >/dev/null 2>&1 || { 
        echo "‚ùå cast is required: install Foundry"
        exit 1
    }
    
    echo "‚úÖ All prerequisites satisfied"
}

# Create reference build for upgrades
create_reference_build() {
    local contract_type="$1"
    local deployed_commit
    local commit_field
    
    # Determine which commit field to use based on contract type
    case "$contract_type" in
        zkc)
            commit_field="zkc-commit"
            ;;
        vezkc)
            commit_field="vezkc-commit"
            ;;
        staking)
            commit_field="staking-rewards-commit"
            ;;
        *)
            echo "‚ùå Unknown contract type: $contract_type"
            exit 1
            ;;
    esac
    
    echo "Creating reference build for $contract_type upgrade safety checks..."
    
    # Get deployed commit from deployment.toml
    deployed_commit=$(python3 -c "
import tomlkit
doc = tomlkit.load(open('deployment.toml'))
commit = doc['deployment']['$CHAIN_KEY'].get('$commit_field', '')
if not commit:
    raise Exception('No $commit_field found for $CHAIN_KEY')
print(commit.strip())
")
    
    if [[ -z "$deployed_commit" ]]; then
        echo "‚ùå No deployment commit found for $CHAIN_KEY"
        echo "Cannot create reference build for upgrade"
        exit 1
    fi
    
    echo "üì¶ Creating reference build from commit: $deployed_commit"
    
    # Check if reference build already exists for this commit
    local reference_dir="build-info-reference-${deployed_commit}"
    if [[ -d "$reference_dir" ]] && [[ -n "$(ls -A "$reference_dir" 2>/dev/null)" ]]; then
        echo "‚úÖ Reference build already exists for commit $deployed_commit"
        echo "üìÅ Using cached reference build: $reference_dir"
        echo "üìÅ Build info files: $(ls -1 "$reference_dir" | wc -l) files"
        return 0
    fi
    
    # Create worktree for reference build
    local worktree_path="../${contract_type}-reference-${deployed_commit}"
    
    # Clean up existing worktree if it exists
    if [[ -d "$worktree_path" ]]; then
        echo "üßπ Cleaning up existing reference worktree..."
        git worktree remove "$worktree_path" --force 2>/dev/null || true
    fi
    
    # Create new worktree
    git worktree add "$worktree_path" "$deployed_commit"
    
    # Build reference and copy build info
    echo "üî® Building reference contracts..."
    (
        cd "$worktree_path"
        # Clean and do a full build to ensure complete build info
        forge clean
        
        # Check if [profile.reference] exists in foundry.toml
        if grep -q '^\[profile\.reference\]' foundry.toml 2>/dev/null; then
            echo "üìã Found [profile.reference] in foundry.toml, using reference profile..."
            FOUNDRY_PROFILE=reference forge build
            
            # Check if build info was created
            if [[ ! -d "out-reference/build-info" ]] || [[ -z "$(ls -A out-reference/build-info 2>/dev/null)" ]]; then
                echo "‚ùå No build info created in reference build"
                echo "This may cause upgrade validation to fail"
            else
                mkdir -p "$OLDPWD/build-info-reference-${deployed_commit}"
                cp -R out-reference/build-info/* "$OLDPWD/build-info-reference-${deployed_commit}/"
            fi
        else
            echo "üìã No [profile.reference] found in foundry.toml, using command-line flags..."
            forge build --out out-reference --build-info --build-info-path out-reference/build-info --extra-output storageLayout
            
            # Check if build info was created
            if [[ ! -d "out-reference/build-info" ]] || [[ -z "$(ls -A out-reference/build-info 2>/dev/null)" ]]; then
                echo "‚ùå No build info created with command-line flags"
                echo "This may cause upgrade validation to fail"
            else
                mkdir -p "$OLDPWD/build-info-reference-${deployed_commit}"
                cp -R out-reference/build-info/* "$OLDPWD/build-info-reference-${deployed_commit}/"
            fi
        fi
    )
    
    # Clean up worktree
    git worktree remove "$worktree_path" --force
    
    # Verify build info was copied
    if [[ -d "build-info-reference-${deployed_commit}" ]] && [[ -n "$(ls -A "build-info-reference-${deployed_commit}" 2>/dev/null)" ]]; then
        echo "‚úÖ Reference build created in build-info-reference-${deployed_commit}/"
        echo "üìÅ Build info files: $(ls -1 "build-info-reference-${deployed_commit}" | wc -l) files"
    else
        echo "‚ùå Failed to create reference build info"
        echo "This may cause upgrade validation to fail"
    fi
}

# Execute forge script with proper configuration
forge_script() {
    local script_name="$1"
    shift
    
    echo "üöÄ Executing $script_name..."
    
    # Determine the correct script file
    local script_file
    if [[ "$script_name" == Deploy* ]]; then
        script_file="Deploy.s.sol"
    elif [[ "$script_name" == Upgrade* ]]; then
        script_file="Upgrade.s.sol"
    elif [[ "$script_name" == "ZKCStartEpochs" ]]; then
        script_file="Upgrade.s.sol"
    elif [[ "$script_name" == Rollback* ]]; then
        script_file="Rollback.s.sol"
    elif [[ "$script_name" == Update* ]]; then
        script_file="Update.s.sol"
    elif [[ "$script_name" == Add* ]] || [[ "$script_name" == Remove* ]]; then
        script_file="Update.s.sol"
    elif [[ "$script_name" == Dev_* ]]; then
        script_file="Ops.s.sol"
    else
        echo "‚ùå Unknown script type: $script_name"
        exit 1
    fi
    
    local cmd="forge script script/$script_file:$script_name"
    cmd="$cmd --rpc-url $RPC_URL"
    
    # Add etherscan verification if available
    if [[ -n "${ETHERSCAN_API_KEY:-}" ]]; then
        cmd="$cmd --etherscan-api-key $ETHERSCAN_API_KEY"
    fi
    
    # Configure signing method
    if [[ "$USE_FIREBLOCKS" == "true" ]]; then
        if ! command -v fireblocks-json-rpc >/dev/null 2>&1; then
            echo "‚ùå fireblocks-json-rpc not found in PATH"
            echo "Install from: https://github.com/fireblocks/fireblocks-json-rpc"
            exit 1
        fi
        
        if [[ -z "${FIREBLOCKS_API_KEY:-}" ]]; then
            echo "‚ùå FIREBLOCKS_API_KEY not set"
            exit 1
        fi
        
        cmd="fireblocks-json-rpc --http -- $cmd"
    else
        cmd="$cmd --private-key $PRIVATE_KEY"
    fi
    
    # Add optional flags
    for arg in "$@"; do
        cmd="$cmd $arg"
    done
    
    echo "üìù Running: $cmd"
    eval "$cmd"
    
    # deployment.toml is now updated automatically via FFI calls in the Solidity scripts
    if [[ "$script_name" == "Deploy"* ]] && [[ " $@ " == *" --broadcast "* ]]; then
        echo "‚úÖ Deployment completed - deployment.toml updated automatically"
    elif [[ "$script_name" == "Upgrade"* ]] && [[ " $@ " == *" --broadcast "* ]]; then
        echo "‚úÖ Upgrade completed - deployment.toml updated automatically"
    fi
}

# Deployment.toml is now updated automatically via FFI calls in Solidity scripts

# Print usage information
usage() {
    cat << EOF
Usage: $0 <command> [options]

Commands:
  deploy-zkc             Deploy ZKC token contract
  deploy-vezkc           Deploy veZKC staking contract
  deploy-staking         Deploy StakingRewards contract
  deploy-circulating     Deploy CirculatingZKC contract
  upgrade-zkc            Upgrade ZKC implementation (no initializer)
  upgrade-zkc-initv2     Upgrade ZKC implementation and call initializeV2
  zkc-start-epochs       Call initializeV3 to start epochs (no upgrade)
  upgrade-vezkc          Upgrade veZKC implementation  
  upgrade-staking        Upgrade StakingRewards implementation
  rollback-zkc           Rollback ZKC to previous implementation
  rollback-vezkc         Rollback veZKC to previous implementation
  rollback-staking       Rollback StakingRewards to previous implementation
  update-povw-minter     Set POVW_MINTER_ROLE in ZKC contract
  update-staking-minter  Set STAKING_MINTER_ROLE in ZKC contract
  update-circulating     Update unlocked value in CirculatingZKC contract
  add-zkc-admin          Add admin to ZKC contract
  remove-zkc-admin       Remove admin from ZKC contract
  add-vezkc-admin        Add admin to veZKC contract
  remove-vezkc-admin     Remove admin from veZKC contract
  add-staking-admin      Add admin to StakingRewards contract
  remove-staking-admin   Remove admin from StakingRewards contract
  add-admin-all          Add admin to all contracts (ZKC, veZKC, StakingRewards)
  remove-admin-all       Remove admin from all contracts (ZKC, veZKC, StakingRewards)
  dev-mint-to-self       Development: mint initial tokens to caller

Options:
  -f, --fireblocks       Use Fireblocks for transaction signing
  --broadcast            Broadcast transactions to network
  --verify               Verify contracts on Etherscan
  -h, --help             Show this help message

Environment Variables:
  CHAIN_KEY              Required. Deployment environment key (anvil, ethereum-mainnet, ethereum-sepolia, ethereum-sepolia-staging)
  PRIVATE_KEY            Required. Private key for transaction signing (0x...)
  GNOSIS_EXECUTE         Optional. Set to 'true' to generate Gnosis Safe calldata without executing transactions
  SKIP_SAFETY_CHECKS     Optional. Set to 'true' to skip upgrade safety checks (WARNING: unsafe!)
  ADMIN_TO_ADD           Required for add-*-admin commands. Admin address to grant role to (0x...)
  ADMIN_TO_REMOVE        Required for remove-*-admin commands. Admin address to revoke role from (0x...)
  
Examples:
  # Deploy ZKC to anvil
  CHAIN_KEY=anvil \
  PRIVATE_KEY=0x... \
  INITIAL_MINTER_1="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266" \
  INITIAL_MINTER_2="0x0000000000000000000000000000000000000000" \
  TOTAL_INITIAL_SUPPLY="1000000000000000000000000000" \
  INITIAL_MINTER_1_AMOUNT="1000000000000000000000000000" \
  INITIAL_MINTER_2_AMOUNT="0" \
  SALT="0x0000000000000000000000000000000000000000000000000000000000000001" \
  ADMIN="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266" \
  script/manage deploy-zkc --broadcast
  
  # Deploy veZKC to sepolia with Fireblocks (requires ZKC already deployed)
  PRIVATE_KEY=0x... CHAIN_KEY=ethereum-sepolia ./script/manage deploy-vezkc --fireblocks --broadcast --verify
  
  # Deploy to staging environment
  PRIVATE_KEY=0x... CHAIN_KEY=ethereum-sepolia-staging ./script/manage deploy-zkc --broadcast
  
  # Deploy StakingRewards to anvil (requires ZKC and veZKC already deployed)
  PRIVATE_KEY=0x... CHAIN_KEY=anvil ./script/manage deploy-staking --broadcast

  # Deploy CirculatingZKC to anvil (requires ZKC already deployed)
  PRIVATE_KEY=0x... INITIAL_UNLOCKED="500000000000000000000000000" CHAIN_KEY=anvil ./script/manage deploy-circulating --broadcast
  
  # Upgrade ZKC on mainnet with verification (no initializer)
  PRIVATE_KEY=0x... CHAIN_KEY=ethereum-mainnet ./script/manage upgrade-zkc --broadcast --verify
  
  # Upgrade ZKC and call initializeV2
  PRIVATE_KEY=0x... CHAIN_KEY=ethereum-mainnet ./script/manage upgrade-zkc-initv2 --broadcast --verify
  
  # Start ZKC epochs (call initializeV3 without upgrade)
  PRIVATE_KEY=0x... CHAIN_KEY=ethereum-mainnet ./script/manage zkc-start-epochs --broadcast
  
  # Upgrade ZKC skipping safety checks (WARNING: unsafe!)
  PRIVATE_KEY=0x... CHAIN_KEY=anvil SKIP_SAFETY_CHECKS=true ./script/manage upgrade-zkc --broadcast
  
  # Rollback ZKC to previous implementation
  PRIVATE_KEY=0x... CHAIN_KEY=anvil ./script/manage rollback-zkc --broadcast
  
  # Set POVW minter role (requires POVW_MINTER env var)
  PRIVATE_KEY=0x... POVW_MINTER=0x123... CHAIN_KEY=anvil ./script/manage update-povw-minter --broadcast

  # Update CirculatingZKC unlocked value (requires NEW_UNLOCKED env var)
  PRIVATE_KEY=0x... NEW_UNLOCKED="750000000000000000000000000" CHAIN_KEY=anvil ./script/manage update-circulating --broadcast

  
  # Add admin to ZKC contract
  PRIVATE_KEY=0x... ADMIN_TO_ADD=0x123... CHAIN_KEY=anvil ./script/manage add-zkc-admin --broadcast
  
  # Remove admin from veZKC contract
  PRIVATE_KEY=0x... ADMIN_TO_REMOVE=0x123... CHAIN_KEY=anvil ./script/manage remove-vezkc-admin --broadcast
  
  # Add admin to all contracts at once
  PRIVATE_KEY=0x... ADMIN_TO_ADD=0x123... CHAIN_KEY=anvil ./script/manage add-admin-all --broadcast
  
  # Development: mint initial tokens to self (requires MINT_AMOUNT env var)
  PRIVATE_KEY=0x... MINT_AMOUNT=1000000000000000000000000 CHAIN_KEY=anvil ./script/manage dev-mint-to-self --broadcast

Gnosis Safe Examples (GNOSIS_EXECUTE=true):
  # Generate upgrade calldata for Gnosis Safe (deploy implementation only)
  GNOSIS_EXECUTE=true CHAIN_KEY=ethereum-mainnet ./script/manage upgrade-zkc
  
  # Generate initializeV3 calldata for Gnosis Safe
  GNOSIS_EXECUTE=true CHAIN_KEY=ethereum-mainnet ./script/manage zkc-start-epochs
  
  # Generate rollback calldata for Gnosis Safe
  GNOSIS_EXECUTE=true CHAIN_KEY=ethereum-mainnet ./script/manage rollback-zkc
  
  # Generate role grant calldata for Gnosis Safe
  GNOSIS_EXECUTE=true POVW_MINTER=0x123... CHAIN_KEY=ethereum-mainnet ./script/manage update-povw-minter
  
  # Generate admin grant calldata for Gnosis Safe
  GNOSIS_EXECUTE=true ADMIN_TO_ADD=0x123... CHAIN_KEY=ethereum-mainnet ./script/manage add-zkc-admin
  
  # Generate admin revoke calldata for Gnosis Safe
  GNOSIS_EXECUTE=true ADMIN_TO_REMOVE=0x123... CHAIN_KEY=ethereum-mainnet ./script/manage remove-staking-admin
  
  # Generate admin management for all contracts at once
  GNOSIS_EXECUTE=true ADMIN_TO_ADD=0x123... CHAIN_KEY=ethereum-mainnet ./script/manage add-admin-all

  # Generate CirculatingZKC update calldata for Gnosis Safe
  GNOSIS_EXECUTE=true NEW_UNLOCKED="750000000000000000000000000" CHAIN_KEY=ethereum-mainnet ./script/manage update-circulating

Notes:
  - Network configuration is loaded from deployment.toml and deployment_secrets.toml
  - Private keys must be provided via PRIVATE_KEY environment variable
  - Upgrades require reference builds for safety checks
  - Fireblocks requires fireblocks-json-rpc to be installed
  - All deployments automatically update deployment.toml
EOF
}

# Main execution logic
main() {
    echo "üîß ZKC Deployment Manager"
    echo "=========================="
    
    # Parse flags first
    USE_FIREBLOCKS=false
    SCRIPT_ARGS=()
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--fireblocks)
                USE_FIREBLOCKS=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            deploy-*|upgrade-*|rollback-*|update-*|add-*|remove-*|dev-*|zkc-start-epochs)
                COMMAND="$1"
                shift
                ;;
            *)
                SCRIPT_ARGS+=("$1")
                shift
                ;;
        esac
    done
    
    # Check for required command
    if [[ -z "${COMMAND:-}" ]]; then
        echo "‚ùå No command specified"
        usage
        exit 1
    fi
    
    # Check prerequisites
    check_prerequisites
    
    # Required environment variable
    if [[ -z "${CHAIN_KEY:-}" ]]; then
        echo "‚ùå CHAIN_KEY environment variable is required"
        echo "Example: CHAIN_KEY=anvil ./script/manage deploy-all --broadcast"
        exit 1
    fi
    
    echo "üåê Chain: $CHAIN_KEY"
    
    # Load configuration from TOML files
    echo "üìã Loading configuration..."
    load_env_var "rpc-url" "RPC_URL" "deployment_secrets.toml"
    load_env_var "etherscan-api-key" "ETHERSCAN_API_KEY" "deployment_secrets.toml"
    load_env_var "id" "CHAIN_ID"
    
    # PRIVATE_KEY must be set as environment variable
    if [[ -z "${PRIVATE_KEY:-}" ]]; then
        echo "‚ùå PRIVATE_KEY environment variable is required"
        echo "Set it with: export PRIVATE_KEY=0x..."
        exit 1
    fi
    
    if [[ "$USE_FIREBLOCKS" == "true" ]]; then
        load_env_var "fireblocks-api-key" "FIREBLOCKS_API_KEY" "deployment_secrets.toml"
        echo "üîê Using Fireblocks for signing"
    fi
    
    # Verify required configuration
    if [[ -z "${RPC_URL:-}" ]]; then
        echo "‚ùå RPC URL not configured for $CHAIN_KEY"
        exit 1
    fi
    
    if [[ -z "${CHAIN_ID:-}" ]]; then
        echo "‚ùå Chain ID not configured for $CHAIN_KEY"
        exit 1
    fi
    
    # Verify chain ID matches RPC
    echo "üîç Verifying chain configuration..."
    actual_chain_id=$(cast chain-id --rpc-url "$RPC_URL" 2>/dev/null || echo "")
    if [[ "$actual_chain_id" != "$CHAIN_ID" ]]; then
        echo "‚ùå Chain ID mismatch:"
        echo "   Expected: $CHAIN_ID (from deployment.toml)"
        echo "   Actual:   $actual_chain_id (from RPC)"
        exit 1
    fi
    echo "‚úÖ Chain ID verified: $CHAIN_ID"
    
    # Create reference build for upgrade commands (unless skipping safety checks)
    if [[ "$COMMAND" == upgrade-* ]]; then
        if [[ "${SKIP_SAFETY_CHECKS:-false}" == "true" ]]; then
            echo "‚ö†Ô∏è  SKIP_SAFETY_CHECKS=true - Skipping reference build creation"
            echo "‚ö†Ô∏è  WARNING: Upgrade safety checks will be disabled!"
        else
            # Extract contract type from command
            local contract_type=""
            case "$COMMAND" in
                upgrade-zkc|upgrade-zkc-initv2)
                    contract_type="zkc"
                    ;;
                upgrade-vezkc)
                    contract_type="vezkc"
                    ;;
                upgrade-staking)
                    contract_type="staking"
                    ;;
                *)
                    echo "‚ùå Unknown upgrade command: $COMMAND"
                    exit 1
                    ;;
            esac
            
            create_reference_build "$contract_type"
        fi
        
        # Always ensure current build is clean and complete for all upgrades
        echo "üßπ Cleaning current build artifacts..."
        forge clean
        echo "üî® Rebuilding all contracts for upgrade..."
        forge build
        echo "‚úÖ Current build completed successfully"
    fi
    
    # Execute the requested command
    case "$COMMAND" in
        deploy-zkc)
            forge_script "DeployZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        deploy-vezkc)
            forge_script "DeployVeZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        deploy-staking)
            forge_script "DeployStakingRewards" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        deploy-circulating)
            forge_script "DeployCirculatingZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        upgrade-zkc)
            forge_script "UpgradeZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        upgrade-zkc-initv2)
            forge_script "UpgradeZKC_InitV2" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        zkc-start-epochs)
            forge_script "ZKCStartEpochs" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        upgrade-vezkc)
            forge_script "UpgradeVeZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        upgrade-staking)
            forge_script "UpgradeStakingRewards" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        rollback-zkc)
            forge_script "RollbackZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        rollback-vezkc)
            forge_script "RollbackVeZKC" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        rollback-staking)
            forge_script "RollbackStakingRewards" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        update-povw-minter)
            forge_script "UpdatePOVWMinter" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        update-staking-minter)
            forge_script "UpdateStakingMinter" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        update-circulating)
            forge_script "UpdateCirculatingUnlocked" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        add-zkc-admin)
            forge_script "AddZKCAdmin" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        remove-zkc-admin)
            forge_script "RemoveZKCAdmin" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        add-vezkc-admin)
            forge_script "AddVeZKCAdmin" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        remove-vezkc-admin)
            forge_script "RemoveVeZKCAdmin" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        add-staking-admin)
            forge_script "AddStakingRewardsAdmin" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        remove-staking-admin)
            forge_script "RemoveStakingRewardsAdmin" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        add-admin-all)
            forge_script "AddAdminAll" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        remove-admin-all)
            forge_script "RemoveAdminAll" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        dev-mint-to-self)
            forge_script "Dev_InitialMintToSelf" "${SCRIPT_ARGS[@]+"${SCRIPT_ARGS[@]}"}"
            ;;
        *)
            echo "‚ùå Unknown command: $COMMAND"
            usage
            exit 1
            ;;
    esac
    
    echo ""
    echo "‚úÖ Command completed successfully: $COMMAND"
    echo "=========================="
}

# Run main function with all arguments
main "$@"